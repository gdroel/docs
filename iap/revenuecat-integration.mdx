---
title: 'RevenueCat Integration'
description: 'Use ZeroSettle alongside RevenueCat for web checkout'
icon: 'puzzle-piece'
---

ZeroSettle works alongside RevenueCat. You can use RevenueCat for StoreKit and Play Billing subscription management while routing eligible purchases through ZeroSettle's web checkout for lower fees.

There are two integration approaches:

## Option 1: SDK Integration (Recommended)

Use the ZeroSettleKit SDK alongside RevenueCat in your app. This gives you full control over the purchase flow.

### Configuration

When using RevenueCat, disable ZeroSettle's StoreKit/Play Billing listener to avoid conflicts:

<CodeGroup>
```swift Swift
import ZeroSettleKit
import RevenueCat

@main
struct YourApp: App {
    init() {
        // Configure RevenueCat first
        Purchases.configure(withAPIKey: "your_revenuecat_key")

        // Configure ZeroSettle with StoreKit sync disabled
        ZeroSettle.shared.configure(.init(
            publishableKey: "your_zerosettle_key",
            syncStoreKitTransactions: false  // RevenueCat manages StoreKit
        ))
    }

    var body: some Scene {
        WindowGroup {
            ContentView()
                .zeroSettleHandler()
        }
    }
}
```

```kotlin Kotlin
import com.zerosettle.sdk.ZeroSettle
import com.revenuecat.purchases.Purchases
import com.revenuecat.purchases.PurchasesConfiguration

class MyApp : Application() {
    override fun onCreate() {
        super.onCreate()

        // Configure RevenueCat first
        Purchases.configure(
            PurchasesConfiguration.Builder(this, "your_revenuecat_key").build()
        )

        // Configure ZeroSettle with Play Store sync disabled
        ZeroSettle.configure(this, ZeroSettle.Configuration(
            publishableKey = "your_zerosettle_key",
            syncPlayStoreTransactions = false,  // RevenueCat manages Play Billing
        ))
    }
}
```

```tsx React Native
import { ZeroSettle } from 'react-native-zerosettle-kit';
import Purchases from 'react-native-purchases';

// Configure RevenueCat first
Purchases.configure({ apiKey: 'your_revenuecat_key' });

// Configure ZeroSettle with StoreKit sync disabled
await ZeroSettle.configure({
  publishableKey: 'your_zerosettle_key',
  syncStoreKitTransactions: false,
});
```

```dart Flutter
import 'package:zerosettle/zerosettle.dart';
import 'package:purchases_flutter/purchases_flutter.dart';

// Configure RevenueCat first
await Purchases.configure(PurchasesConfiguration('your_revenuecat_key'));

// Configure ZeroSettle with StoreKit sync disabled
await ZeroSettle.instance.configure(
  publishableKey: 'your_zerosettle_key',
  syncStoreKitTransactions: false,
);
```
</CodeGroup>

<Warning>
  Always set `syncStoreKitTransactions: false` (iOS) or `syncPlayStoreTransactions: false` (Android) when using RevenueCat. Both SDKs listening for store transactions will cause conflicts.
</Warning>

### User Identity

Pass RevenueCat's `appUserID` as the `userId` when making ZeroSettle purchases. This links web checkout purchases to the correct RevenueCat customer:

<CodeGroup>
```swift Swift
let rcUserId = Purchases.shared.appUserID

// Fetch ZeroSettle product catalog
let catalog = try await ZeroSettle.shared.fetchProducts(userId: rcUserId)

// Purchase via web checkout using .checkoutSheet() in your SwiftUI view:
// .checkoutSheet(item: $selectedProduct, userId: rcUserId) { result in ... }
```

```kotlin Kotlin
val rcUserId = Purchases.sharedInstance.appUserID

// Fetch ZeroSettle product catalog
val catalog = ZeroSettle.fetchProducts(userId = rcUserId)

// Purchase via web checkout
val transaction = ZeroSettle.purchase(
    activity = this,
    productId = product.id,
    userId = rcUserId,
)
```

```tsx React Native
const rcUserId = await Purchases.getAppUserID();

const catalog = await ZeroSettle.fetchProducts(rcUserId);

const transaction = await ZeroSettle.purchase(product.id, rcUserId);
```

```dart Flutter
final rcUserId = await Purchases.appUserID;

final catalog = await ZeroSettle.instance.fetchProducts(userId: rcUserId);

final transaction = await ZeroSettle.instance.presentPaymentSheet(
  productId: product.id,
  userId: rcUserId,
);
```
</CodeGroup>

### Hybrid Paywall

Show both ZeroSettle (web checkout) and RevenueCat (StoreKit/Play Billing) purchase options:

<CodeGroup>
```swift Swift
struct PaywallView: View {
    @State private var selectedProduct: ZSProduct?
    let zsProduct: ZSProduct      // From ZeroSettleKit
    let rcPackage: Package        // From RevenueCat

    var body: some View {
        VStack(spacing: 16) {
            // Web checkout — lower fees
            Button("Subscribe — \(zsProduct.webPrice.formatted)") {
                selectedProduct = zsProduct
            }
            .checkoutSheet(
                item: $selectedProduct,
                userId: Purchases.shared.appUserID
            ) { result in
                if case .success = result {
                    // Refresh RC customer info to pick up the webhook
                    try? await Purchases.shared.customerInfo()
                }
            }

            // StoreKit fallback via RevenueCat
            Button("Subscribe via App Store — \(rcPackage.localizedPriceString)") {
                Task {
                    try? await Purchases.shared.purchase(package: rcPackage)
                }
            }
            .foregroundStyle(.secondary)
        }
    }
}
```

```kotlin Kotlin
@Composable
fun PaywallScreen(zsProduct: ZSProduct, rcPackage: Package) {
    val context = LocalContext.current
    val scope = rememberCoroutineScope()

    Column(verticalArrangement = Arrangement.spacedBy(16.dp)) {
        // Web checkout — lower fees
        Button(onClick = {
            scope.launch {
                try {
                    ZeroSettle.purchase(
                        activity = context as Activity,
                        productId = zsProduct.id,
                        userId = Purchases.sharedInstance.appUserID,
                    )
                    // Refresh RC customer info to pick up the webhook
                    Purchases.sharedInstance.getCustomerInfo(
                        object : ReceiveCustomerInfoCallback { /* ... */ }
                    )
                } catch (_: ZSError.Cancelled) { }
            }
        }) {
            Text("Subscribe — ${zsProduct.webPrice?.formatted}")
        }

        // Play Store fallback via RevenueCat
        TextButton(onClick = {
            scope.launch {
                Purchases.sharedInstance.purchase(
                    PurchaseParams.Builder(context as Activity, rcPackage).build(),
                    object : PurchaseCallback { /* ... */ }
                )
            }
        }) {
            Text("Subscribe via Play Store — ${rcPackage.product.price.formatted}")
        }
    }
}
```

```tsx React Native
// Web checkout — lower fees
const handleWebPurchase = async () => {
  try {
    await ZeroSettle.purchase(zsProduct.id, Purchases.getAppUserID());
    // Refresh RC customer info
    await Purchases.getCustomerInfo();
  } catch (e) {
    if (e.code !== 'cancelled') showError(e.message);
  }
};

// StoreKit/Play Store fallback via RevenueCat
const handleStorePurchase = async () => {
  await Purchases.purchasePackage(rcPackage);
};
```

```dart Flutter
// Web checkout — lower fees
try {
  final transaction = await ZeroSettle.instance.presentPaymentSheet(
    productId: zsProduct.id,
    userId: await Purchases.appUserID,
  );
  // Refresh RC customer info
  await Purchases.getCustomerInfo();
} on ZSCancelledException {
  // User cancelled
}

// StoreKit/Play Store fallback via RevenueCat
await Purchases.purchasePackage(rcPackage);
```
</CodeGroup>

## Option 2: RevenueCat Paywall Custom Button

If you use RevenueCat's paywall builder, you can add a custom checkout button that links to ZeroSettle's hosted checkout:

1. In your RevenueCat paywall template, add a purchase button with **custom checkout**
2. Set the URL to your ZeroSettle checkout link
3. Configure a URL scheme in your app to handle the callback

### Handle the Callback

<CodeGroup>
```swift Swift
@main
struct YourApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .onOpenURL { url in
                    if url.scheme == "yourapp" {
                        let status = url.lastPathComponent
                        switch status {
                        case "success":
                            // Refresh RevenueCat customer info
                            Task {
                                try? await Purchases.shared.customerInfo()
                            }
                        case "cancelled":
                            break
                        default:
                            break
                        }
                    }
                }
        }
    }
}
```

```kotlin Kotlin
// In your Activity that handles the deep link
override fun onNewIntent(intent: Intent?) {
    super.onNewIntent(intent)
    intent?.data?.let { uri ->
        if (uri.scheme == "yourapp") {
            when (uri.lastPathSegment) {
                "success" -> {
                    // Refresh RevenueCat customer info
                    Purchases.sharedInstance.getCustomerInfo(
                        object : ReceiveCustomerInfoCallback {
                            override fun onReceived(customerInfo: CustomerInfo) {
                                updateUI(customerInfo)
                            }
                            override fun onError(error: PurchasesError) { }
                        }
                    )
                }
                "cancelled" -> { /* no-op */ }
            }
        }
    }
}
```

```tsx React Native
import { Linking } from 'react-native';
import Purchases from 'react-native-purchases';

Linking.addEventListener('url', async ({ url }) => {
  const parsed = new URL(url);
  if (parsed.pathname.endsWith('success')) {
    await Purchases.getCustomerInfo();
  }
});
```

```dart Flutter
// Handle deep link callback
void handleDeepLink(Uri uri) async {
  if (uri.pathSegments.last == 'success') {
    await Purchases.getCustomerInfo();
  }
}
```
</CodeGroup>

<Note>
  The SDK integration (Option 1) provides a better user experience since the payment sheet stays inside your app. The custom button approach is useful if you want to use RevenueCat's paywall builder without writing custom UI code.
</Note>
