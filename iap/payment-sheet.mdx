---
title: 'Payment Sheet'
description: 'Embedded checkout UI with Apple Pay and card support'
icon: 'credit-card'
---

`ZSPaymentSheet` is an embedded checkout experience that presents a native-feeling bottom sheet inside your app. Users can pay with Apple Pay or enter a card — without ever leaving your app.

This is the recommended way to accept payments with ZeroSettle.

## SwiftUI

### Basic Usage

Use the `.zsPaymentSheet()` view modifier to present the payment sheet:

```swift
struct PaywallView: View {
    @State private var showCheckout = false
    let product: ZSProduct

    var body: some View {
        Button("Subscribe — \(product.webPrice.formatted)") {
            showCheckout = true
        }
        .zsPaymentSheet(
            isPresented: $showCheckout,
            product: product,
            userId: currentUser.id
        ) { result in
            switch result {
            case .success(let transaction):
                unlockContent(transaction.productId)
            case .failure(let error):
                showError(error)
            }
        }
    }
}
```

### Custom Header

Add a custom header view above the payment sheet to show product details, branding, or promotional messaging:

```swift
.zsPaymentSheet(
    isPresented: $showCheckout,
    product: product,
    userId: currentUser.id,
    header: {
        VStack(spacing: 8) {
            Image("premium-icon")
                .resizable()
                .frame(width: 60, height: 60)
            Text(product.displayName)
                .font(.title2.bold())
            Text(product.productDescription)
                .font(.subheadline)
                .foregroundStyle(.secondary)
        }
        .padding()
    }
) { result in
    // Handle result
}
```

### Item-Based Presentation

If you have an optional `ZSProduct?` binding (e.g., a selected product from a list), use the item-based modifier. The sheet presents when the binding is non-nil and automatically sets it back to `nil` on dismiss:

```swift
struct PaywallView: View {
    @ObservedObject var iap = ZeroSettleIAP.shared
    @State private var selectedProduct: ZSProduct?

    var body: some View {
        ForEach(iap.products) { product in
            Button(product.displayName) {
                selectedProduct = product
            }
        }
        .zsPaymentSheet(
            item: $selectedProduct,
            userId: currentUser.id
        ) { result in
            handleResult(result)
        }
    }
}
```

### Non-Dismissable Sheet

Pass `dismissable: false` to prevent the user from swiping to dismiss the sheet. This hides the close button and disables interactive dismiss:

```swift
.zsPaymentSheet(
    isPresented: $showCheckout,
    product: product,
    userId: currentUser.id,
    dismissable: false
) { result in
    handleResult(result)
}
```

### Direct View Usage

You can also use `ZSPaymentSheet` as a standalone view, for example inside a `.sheet()`:

```swift
.sheet(isPresented: $showCheckout) {
    ZSPaymentSheet(
        product: product,
        userId: currentUser.id
    ) { result in
        showCheckout = false
        handleResult(result)
    }
}
```

Or with a custom header:

```swift
.sheet(isPresented: $showCheckout) {
    ZSPaymentSheet(
        product: product,
        userId: currentUser.id,
        header: {
            Text("Premium Access")
                .font(.title.bold())
                .padding()
        }
    ) { result in
        showCheckout = false
        handleResult(result)
    }
}
```

## UIKit

Present the payment sheet from any view controller:

```swift
ZSPaymentSheet.present(
    from: self,
    product: product,
    userId: currentUser.id
) { result in
    switch result {
    case .success(let transaction):
        self.unlockContent(transaction.productId)
    case .failure(let error):
        self.showError(error)
    }
}
```

You can also pass `dismissable: false`, or provide a preloaded `checkoutURL` and `transactionId` for instant presentation:

```swift
ZSPaymentSheet.present(
    from: self,
    product: product,
    userId: currentUser.id,
    dismissable: false,
    checkoutURL: preloadedURL,
    transactionId: preloadedTransactionId
) { result in
    handleResult(result)
}
```

## Choosing a Presentation API

The payment sheet offers two SwiftUI modifier styles. Choose based on your UI pattern:

| | `isPresented:` | `item:` |
|---|---|---|
| **Binding type** | `Binding<Bool>` | `Binding<ZSProduct?>` |
| **Best for** | Single-product paywalls, "Buy Now" buttons | Product lists, multi-product stores |
| **Product source** | Passed as a separate parameter | Driven by the binding itself |
| **Dismiss behavior** | You set `isPresented = false` | Automatically sets `item = nil` |
| **Re-open speed** | Fast — preloader stays alive, cache hit | Fast — preloader survives nil/non-nil transitions |

<Tip>
  **Use `item:`** when the user picks from a list of products — it mirrors SwiftUI's `.sheet(item:)` pattern and is the most ergonomic API for multi-product stores.

  **Use `isPresented:`** when you have a fixed product and a simple "Buy" button.
</Tip>

Both APIs share the same caching and preloading behavior described below.

## Performance & Caching

### Automatic Preloading

The `.zsPaymentSheet()` view modifier automatically preloads both the `PaymentIntent` and the `WKWebView` before presenting the sheet. When the user taps "Buy", the checkout is fully rendered the moment it slides up — no manual preloading is needed.

```swift
// The modifier handles preloading automatically — just use it as normal
.zsPaymentSheet(
    isPresented: $showCheckout,
    product: product,
    userId: currentUser.id
) { result in
    handleResult(result)
}
```

### Built-In Caching

The SDK automatically caches `PaymentIntent` results (the checkout URL and transaction ID) for **5 minutes**. This means:

- **Re-opens after dismiss are near-instant** — if the user dismisses and re-opens the sheet for the same product, the API call is skipped entirely. Only the WebView needs to reload.
- **The cache is shared** across all payment sheet instances in your app.
- **The cache invalidates automatically** after a successful payment, so the next open gets a fresh `PaymentIntent`.

No code changes are needed to benefit from caching — it works automatically with both `isPresented:` and `item:` APIs.

### Eager Warm-Up

For the fastest possible first open, call `ZSPaymentSheet.warmUp()` as soon as you know which product the user is likely to buy. This pre-creates the `PaymentIntent` in the background and caches the result:

```swift
struct StoreView: View {
    @State private var products: [ZSProduct] = []
    @State private var selectedProduct: ZSProduct?

    var body: some View {
        ProductList(products: products, selection: $selectedProduct)
            .task {
                products = (try? await ZeroSettleIAP.shared.fetchProducts())?.products ?? []

                // Pre-cache the PaymentIntent so the first sheet open is instant
                if let first = products.first {
                    await ZSPaymentSheet.warmUp(
                        productId: first.id,
                        userId: currentUser.id
                    )
                }
            }
            .zsPaymentSheet(item: $selectedProduct, userId: currentUser.id) { result in
                handleResult(result)
            }
    }
}
```

<Tip>
  Call `warmUp()` right after fetching products. The `PaymentIntent` is cached for 5 minutes, so even if the user browses for a while before purchasing, the cache will likely still be warm.
</Tip>

You can warm up multiple products if your UI makes it likely the user will buy any of them:

```swift
.task {
    let catalog = try await ZeroSettleIAP.shared.fetchProducts()

    // Warm up the most popular products
    for product in catalog.products.prefix(3) {
        await ZSPaymentSheet.warmUp(productId: product.id, userId: currentUser.id)
    }
}
```

### UX Impact

Understanding what's cached and what must reload helps you set the right expectations:

| Scenario | API Call | WebView Load | Perceived Speed |
|----------|---------|-------------|-----------------|
| First open (no warm-up) | Network call | Full load | ~1-2s depending on network |
| First open (with `warmUp()`) | Cache hit | Full load | ~0.5-1s (WebView only) |
| Re-open after dismiss (same product) | Cache hit | Full load | ~0.5-1s (WebView only) |
| Re-open after successful payment | Network call | Full load | ~1-2s (cache was invalidated) |

The API call is typically 200-500ms. Warm-up eliminates this entirely for the first open.

### Manual Preloading

For the direct `ZSPaymentSheet` init or UIKit's `present` method, you can preload the `PaymentIntent` yourself using `ZSPaymentSheet.preload()`:

```swift
// Preload while the user browses
let preloaded = await ZSPaymentSheet.preload(
    productId: product.id,
    userId: currentUser.id
)

// Later, pass the preloaded data to the direct init
.sheet(isPresented: $showCheckout) {
    ZSPaymentSheet(
        product: product,
        userId: currentUser.id,
        checkoutURL: preloaded?.checkoutURL,
        transactionId: preloaded?.transactionId
    ) { result in
        handleResult(result)
    }
}
```

<Note>
  `preload()` also populates the cache, so subsequent calls for the same product + user are instant. `warmUp()` is just a convenience wrapper around `preload()`.
</Note>

<Tip>
  Manual preloading is only needed when using `ZSPaymentSheet` as a standalone view or via UIKit's `present` method. The `.zsPaymentSheet()` modifier handles this automatically.
</Tip>

## How It Works

Under the hood, `ZSPaymentSheet`:

1. Checks the `PaymentIntent` cache (5-min TTL) — on a cache hit, skips the network call
2. If no cache hit, creates a Stripe `PaymentIntent` via the ZeroSettle API and caches the result
3. Loads the checkout page in a `WKWebView` with Apple Pay and card entry
4. Communicates payment status back to your app via a JavaScript bridge
5. Verifies the transaction server-side and invalidates the cache for this product
6. Returns a `ZSTransaction` to your completion handler

The user sees a native-looking sheet with Apple Pay as the primary option and a card form as fallback.

## Error Handling

The completion handler receives a `Result<ZSTransaction, Error>`. Payment-specific errors are of type `PaymentSheetError`:

```swift
) { result in
    switch result {
    case .success(let transaction):
        unlockContent(transaction.productId)

    case .failure(let error):
        if let sheetError = error as? PaymentSheetError {
            switch sheetError {
            case .cancelled:
                // User dismissed the sheet — no action needed
                break
            case .notConfigured:
                // SDK not configured — call configure() first
                break
            case .presentationFailed:
                // Could not present the sheet
                break
            case .invalidCard:
                // Card was declined or invalid
                showError("Please check your card details.")
            case .paymentFailed(let message):
                // Payment processing failed
                showError(message)
            }
        }
    }
}
```

### Error Types

| Error | Description |
|-------|-------------|
| `PaymentSheetError.cancelled` | User dismissed the payment sheet |
| `PaymentSheetError.notConfigured` | SDK hasn't been configured yet |
| `PaymentSheetError.presentationFailed` | Sheet couldn't be presented (e.g., no root view controller) |
| `PaymentSheetError.invalidCard` | Card was declined or invalid |
| `PaymentSheetError.paymentFailed(String)` | Payment failed with a message from Stripe |

<Note>
  `.cancelled` is not a real error — it just means the user changed their mind. Don't show an error message for cancellations.
</Note>

## Promotions

If a product has an active promotion, the payment sheet automatically shows the promotional price. The `ZSProduct.promotion` property contains the details:

```swift
if let promo = product.promotion {
    print("\(promo.displayName): \(promo.promotionalPrice.formatted)")
    // e.g. "Launch Sale: $4.99"
}
```

Promotion types include:
- **Percent off** — e.g., 50% off
- **Fixed amount** — e.g., $5 off
- **Free trial** — e.g., 7 days free

## Next Steps

<CardGroup cols={2}>
  <Card title="Universal Links" icon="link" href="/iap/universal-links">
    Required setup for Safari checkout flows
  </Card>
  <Card title="StoreKit Integration" icon="apple" href="/iap/storekit-integration">
    Use StoreKit alongside web checkout
  </Card>
</CardGroup>
