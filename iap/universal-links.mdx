---
title: 'Universal Links & Deep Links'
description: 'Configure your app to receive checkout callbacks'
icon: 'link'
---

After a user completes (or cancels) checkout in a browser, ZeroSettle redirects them back to your app via a universal link (iOS) or deep link (Android). This guide covers the setup required to receive these callbacks.

## How It Works

1. User initiates purchase via `.checkoutSheet()` (iOS) or the platform-specific purchase API
2. SDK opens Stripe checkout in Safari
3. User completes payment (or cancels)
4. Stripe redirects to `https://api.zerosettle.io/checkout/callback?...`
5. iOS opens your app via universal link
6. SDK parses the callback and updates entitlements

## Step 1: Add Associated Domains Entitlement

In Xcode, add the Associated Domains capability to your app target:

1. Select your app target in Xcode
2. Go to **Signing & Capabilities**
3. Click **+ Capability**
4. Select **Associated Domains**
5. Add: `applinks:api.zerosettle.io`

Your entitlements file should include:

<CodeGroup>
```xml iOS (Associated Domains)
<key>com.apple.developer.associated-domains</key>
<array>
    <string>applinks:api.zerosettle.io</string>
</array>
```

```xml Android (Intent Filter)
<intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="https" android:host="api.zerosettle.io" />
</intent-filter>
```

```tsx React Native
// React Native handles deep links via native configuration.
// iOS: Add Associated Domains in Xcode (see Swift tab).
// Android: Add intent-filter in AndroidManifest.xml (see Kotlin tab).
```

```dart Flutter
// Flutter handles deep links via the app's native configuration.
// iOS: Add Associated Domains in Xcode (see Swift tab).
// Android: Add intent-filter in AndroidManifest.xml (see Kotlin tab).
```
</CodeGroup>

### Developer Mode

During development, add `?mode=developer` to bypass Apple's AASA caching:

<CodeGroup>
```xml iOS (Developer Mode)
<key>com.apple.developer.associated-domains</key>
<array>
    <string>applinks:api.zerosettle.io?mode=developer</string>
</array>
```

```xml Android (Intent Filter)
<!-- Android App Links use Digital Asset Links for verification.
     There is no separate developer mode — autoVerify works immediately
     once the assetlinks.json file is hosted on the domain. -->
<intent-filter android:autoVerify="true">
    <action android:name="android.intent.action.VIEW" />
    <category android:name="android.intent.category.DEFAULT" />
    <category android:name="android.intent.category.BROWSABLE" />
    <data android:scheme="https" android:host="api.zerosettle.io" />
</intent-filter>
```

```tsx React Native
// React Native handles deep links via native configuration.
// iOS: Add Associated Domains in Xcode (see Swift tab).
// Android: Add intent-filter in AndroidManifest.xml (see Kotlin tab).
// There is no separate developer mode for React Native.
```

```dart Flutter
// Flutter handles deep links via the app's native configuration.
// iOS: Add Associated Domains in Xcode (see Swift tab).
// Android: Add intent-filter in AndroidManifest.xml (see Kotlin tab).
// There is no separate developer mode for Flutter.
```
</CodeGroup>

| Mode | Behavior |
|------|----------|
| Normal | iOS caches the AASA file and refreshes infrequently. Changes can take hours to propagate. |
| Developer | iOS fetches the AASA file directly on each app install, bypassing CDN caching. |

<Note>
  Use `?mode=developer` during development for faster iteration. Remove it before submitting to the App Store—developer mode only works on devices registered in your Apple Developer account.
</Note>

<Warning>
  Associated Domains requires a paid Apple Developer account. The capability won't work with free provisioning profiles.
</Warning>

## Step 2: Register Your App ID

Contact ZeroSettle support to register your app's bundle ID and team ID for universal link handling. You'll need to provide:

| Field | Example | Where to Find |
|-------|---------|---------------|
| Team ID | `YUM5K9J52M` | Apple Developer Portal → Membership |
| Bundle ID | `com.yourcompany.yourapp` | Xcode → Target → General |

ZeroSettle will add your app to the `apple-app-site-association` file hosted at `https://api.zerosettle.io/.well-known/apple-app-site-association`.

## Step 3: Handle the Callback

### SwiftUI

Use the `.zeroSettleHandler()` view modifier on your root view (or handle deep links in your Android Activity):

<CodeGroup>
```swift Swift
@main
struct YourApp: App {
    var body: some Scene {
        WindowGroup {
            ContentView()
                .zeroSettleHandler()
        }
    }
}
```

```kotlin Kotlin
class MainActivity : ComponentActivity() {
    override fun onNewIntent(intent: Intent?) {
        super.onNewIntent(intent)
        intent?.data?.let { uri ->
            ZeroSettle.handleDeepLink(uri)
        }
    }

    override fun onResume() {
        super.onResume()
        ZeroSettle.onResume()
    }
}
```

```tsx React Native
import { ZeroSettle } from 'react-native-zerosettle-kit';
import { Linking } from 'react-native';

// Handle deep links
Linking.addEventListener('url', ({ url }) => {
  ZeroSettle.handleUniversalLink(url);
});
```

```dart Flutter
// Flutter handles deep links automatically via the native plugin.
// Ensure your iOS Associated Domains and Android intent-filter are configured.
await ZeroSettle.instance.handleUniversalLink(url);
```
</CodeGroup>

This automatically handles both `onOpenURL` and `onContinueUserActivity` for you on iOS. On Android, `handleDeepLink` parses the callback URI, and `onResume` lets the SDK poll for transaction status when the user returns from the browser.

### UIKit (SceneDelegate)

<CodeGroup>
```swift Swift
class SceneDelegate: UIResponder, UIWindowSceneDelegate {
    func scene(_ scene: UIScene, continue userActivity: NSUserActivity) {
        guard userActivity.activityType == NSUserActivityTypeBrowsingWeb,
              let url = userActivity.webpageURL else {
            return
        }
        ZeroSettle.shared.handleUniversalLink(url)
    }
}
```

```tsx React Native
// For UIKit SceneDelegate, use the cross-platform deep link handler instead.
// See the SwiftUI / Kotlin tab above for the Linking.addEventListener approach.
```

```dart Flutter
// For UIKit SceneDelegate, use the cross-platform deep link handler instead.
// See the SwiftUI / Kotlin tab above for the handleUniversalLink approach.
```
</CodeGroup>

### UIKit (AppDelegate - iOS 12 and earlier)

<CodeGroup>
```swift Swift
class AppDelegate: UIResponder, UIApplicationDelegate {
    func application(
        _ application: UIApplication,
        continue userActivity: NSUserActivity,
        restorationHandler: @escaping ([UIUserActivityRestoring]?) -> Void
    ) -> Bool {
        guard userActivity.activityType == NSUserActivityTypeBrowsingWeb,
              let url = userActivity.webpageURL else {
            return false
        }
        return ZeroSettle.shared.handleUniversalLink(url)
    }
}
```

```tsx React Native
// For UIKit AppDelegate, use the cross-platform deep link handler instead.
// See the SwiftUI / Kotlin tab above for the Linking.addEventListener approach.
```

```dart Flutter
// For UIKit AppDelegate, use the cross-platform deep link handler instead.
// See the SwiftUI / Kotlin tab above for the handleUniversalLink approach.
```
</CodeGroup>

## Step 4: Handle Checkout Results

Use the delegate to respond to checkout completion:

<CodeGroup>
```swift Swift
class PurchaseManager: ZeroSettleDelegate {
    init() {
        ZeroSettle.shared.delegate = self
    }

    func zeroSettleCheckoutDidComplete(transaction: ZSTransaction) {
        // Purchase successful - unlock content
        unlockProduct(transaction.productId)
        showSuccessMessage()
    }

    func zeroSettleCheckoutDidCancel(productId: String) {
        // User cancelled - no action needed, or show a prompt
    }

    func zeroSettleCheckoutDidFail(productId: String, error: Error) {
        // Something went wrong
        showError(error.localizedDescription)
    }
}
```

```kotlin Kotlin
class PurchaseManager : ZeroSettleDelegate {
    override fun zeroSettleCheckoutDidComplete(transaction: ZSTransaction) {
        // Purchase successful - unlock content
        unlockProduct(transaction.productId)
        showSuccessMessage()
    }

    override fun zeroSettleCheckoutDidCancel(productId: String) {
        // User cancelled - no action needed, or show a prompt
    }

    override fun zeroSettleCheckoutDidFail(productId: String, error: Throwable) {
        // Something went wrong
        showError(error.localizedMessage)
    }
}
```

```tsx React Native
ZeroSettle.onEntitlementUpdate((entitlements) => {
  // Purchase successful - unlock content
  updatePremiumUI(entitlements);
});

// Purchases are handled via try/catch
try {
  const transaction = await ZeroSettle.purchase(productId, userId);
  unlockProduct(transaction.productId);
  showSuccessMessage();
} catch (error) {
  if (error.code === 'cancelled') {
    // User cancelled - no action needed
  } else {
    showError(error.message);
  }
}
```

```dart Flutter
ZeroSettle.instance.entitlementUpdates.listen((entitlements) {
  // Purchase successful - unlock content
  updatePremiumUI(entitlements);
});

// Purchases are handled via try/catch
try {
  final transaction = await ZeroSettle.instance.presentPaymentSheet(
    productId: productId,
    userId: userId,
  );
  unlockProduct(transaction.productId);
  showSuccessMessage();
} on ZSCancelledException {
  // User cancelled - no action needed
} on ZSCheckoutFailedException catch (e) {
  showError(e.message);
}
```
</CodeGroup>

## Callback URL Format

The callback URL contains these parameters:

```
https://api.zerosettle.io/checkout/callback
    ?transaction_id=txn_abc123
    &product_id=premium_monthly
    &status=success
```

| Parameter | Description |
|-----------|-------------|
| `transaction_id` | Unique transaction identifier |
| `product_id` | The product that was purchased |
| `status` | `success` or `cancelled` |

<Note>
  You don't need to parse this URL yourself. The SDK's `handleUniversalLink(_:)` method handles parsing and verification.
</Note>

## Testing Universal Links

### Simulator Limitations

Universal links don't work reliably in the iOS Simulator. Test on a physical device.

### Testing Checklist

1. Install a **development build** on a physical device
2. Ensure the device has internet access
3. Start a purchase flow
4. Complete checkout in Safari
5. Verify you're redirected back to the app

### Debugging Tips

If the redirect isn't working:

1. **Check Associated Domains** - Verify the entitlement is correctly added in Xcode
2. **Verify Registration** - Confirm your app ID is registered with ZeroSettle
3. **Check AASA** - Visit `https://api.zerosettle.io/.well-known/apple-app-site-association` and verify your app ID is listed
4. **Reinstall the App** - iOS caches AASA; reinstalling forces a refresh
5. **Check Console Logs** - Look for `swcd` process logs in Console.app

### Manual Testing

You can test the link handler directly:

<CodeGroup>
```swift Swift
// In your app, simulate a callback
let testURL = URL(string: "https://api.zerosettle.io/checkout/callback?transaction_id=test&product_id=test&status=success")!
ZeroSettle.shared.handleUniversalLink(testURL)
```

```kotlin Kotlin
// In your app, simulate a callback
ZeroSettle.handleDeepLink(
    Uri.parse("https://api.zerosettle.io/checkout/callback?transaction_id=test&product_id=test&status=success")
)
```

```tsx React Native
// In your app, simulate a callback
ZeroSettle.handleUniversalLink(
  'https://api.zerosettle.io/checkout/callback?transaction_id=test&product_id=test&status=success'
);
```

```dart Flutter
// In your app, simulate a callback
await ZeroSettle.instance.handleUniversalLink(
  'https://api.zerosettle.io/checkout/callback?transaction_id=test&product_id=test&status=success',
);
```
</CodeGroup>

## Fallback Handling

If the universal link fails to open your app, users will see the callback page in Safari. This page displays a success/cancel message and provides a button to manually open the app.

To handle this case, you can also:

1. **Poll for transaction status** - The SDK stores a pending transaction ID that can be verified on next app launch
2. **Restore entitlements** - Call `restoreEntitlements(userId:)` on app launch to sync any missed purchases

<CodeGroup>
```swift Swift
// On app launch, restore entitlements to catch missed callbacks
Task {
    let entitlements = try? await ZeroSettle.shared.restoreEntitlements(
        userId: currentUser.id
    )
    updateUI(entitlements)
}
```

```kotlin Kotlin
// On app launch, restore entitlements to catch missed callbacks
lifecycleScope.launch {
    val entitlements = ZeroSettle.restoreEntitlements(userId = currentUser.id)
    val hasPremium = entitlements.any { it.isActive }
    updateUI(entitlements)
}
```

```tsx React Native
// On app launch, restore entitlements to catch missed callbacks
const entitlements = await ZeroSettle.restoreEntitlements(currentUser.id);
updateUI(entitlements);
```

```dart Flutter
// On app launch, restore entitlements to catch missed callbacks
final entitlements = await ZeroSettle.instance.restoreEntitlements(
  userId: currentUser.id,
);
updateUI(entitlements);
```
</CodeGroup>

---

## Android Deep Links

On Android, checkout callbacks arrive via Android App Links (verified deep links). This section covers the equivalent setup for Android apps.

<Note>
  Deep link handling is only needed for Custom Tab and external browser checkout modes. The WebView mode (default) handles callbacks internally — no deep link setup required.
</Note>

### Step 1: Add Intent Filter

In your `AndroidManifest.xml`, add a deep link intent filter to your main Activity:

<CodeGroup>
```xml Android (Intent Filter)
<activity android:name=".MainActivity">
    <intent-filter android:autoVerify="true">
        <action android:name="android.intent.action.VIEW" />
        <category android:name="android.intent.category.DEFAULT" />
        <category android:name="android.intent.category.BROWSABLE" />
        <data
            android:scheme="https"
            android:host="api.zerosettle.io"
            android:pathPrefix="/checkout/callback" />
    </intent-filter>
</activity>
```

```tsx React Native
// React Native handles deep links via native configuration.
// Add the intent-filter above to your Android app's AndroidManifest.xml.
```

```dart Flutter
// Flutter handles deep links via the app's native configuration.
// Add the intent-filter above to your Android app's AndroidManifest.xml.
```
</CodeGroup>

The `android:autoVerify="true"` attribute tells Android to verify the domain via a Digital Asset Links file hosted on `api.zerosettle.io`.

### Step 2: Handle the Callback

In your Activity, handle the deep link in `onNewIntent`:

<CodeGroup>
```kotlin Kotlin
class MainActivity : ComponentActivity() {
    override fun onNewIntent(intent: Intent) {
        super.onNewIntent(intent)
        intent.data?.let { uri ->
            ZeroSettle.handleDeepLink(uri)
        }
    }
}
```

```tsx React Native
import { ZeroSettle } from 'react-native-zerosettle-kit';
import { Linking } from 'react-native';

// Handle deep links
Linking.addEventListener('url', ({ url }) => {
  ZeroSettle.handleUniversalLink(url);
});
```

```dart Flutter
// Flutter handles deep links automatically via the native plugin.
// Ensure your Android intent-filter is configured (see above).
await ZeroSettle.instance.handleUniversalLink(url);
```
</CodeGroup>

### Step 3: Call onResume

On Android, Custom Tabs have no dismiss callback, so the SDK detects the user's return via `onResume`. Call `ZeroSettle.onResume()` from your Activity:

<CodeGroup>
```kotlin Kotlin
override fun onResume() {
    super.onResume()
    ZeroSettle.onResume()
}
```

```tsx React Native
// React Native: onResume is handled automatically by the native module.
// No additional code is needed.
```

```dart Flutter
// Flutter: onResume is handled automatically by the native plugin.
// No additional code is needed.
```
</CodeGroup>

This allows the SDK to poll for transaction status when the user returns from the browser.

---

## Troubleshooting

<AccordionGroup>
  <Accordion title="Universal link opens Safari instead of my app">
    - Reinstall the app to refresh the AASA cache
    - Verify your bundle ID and team ID are registered with ZeroSettle
    - Check that Associated Domains is enabled in your provisioning profile
  </Accordion>
  <Accordion title="handleUniversalLink returns false">
    - The URL may not be a ZeroSettle callback URL
    - Check that the URL host is `api.zerosettle.io`
    - Verify the path starts with `/checkout/callback`
  </Accordion>
  <Accordion title="Delegate methods not called">
    - Ensure `ZeroSettle.shared.delegate` is set before the callback
    - Verify the SDK is configured with `configure()`
    - Check that `handleUniversalLink` is being called from `onOpenURL` or scene delegate
  </Accordion>
</AccordionGroup>
